<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Atelier Pointeurs â€” Visuels, piÃ¨ges et exercices</title>
  <link rel="stylesheet" href="assets/css/cpp_intro.css">
  <meta name="description" content="Annexe pratique sur les pointeurs et rÃ©fÃ©rences en C/C++ : visuels, piÃ¨ges frÃ©quents, exercices corrigÃ©s.">
</head>
<body>
  <div class="presentation-container">
    <a class="back-link" href="index.html">â† Retour au menu</a>

    <!-- Slide 1: Titre -->
    <div class="slide active title-slide">
      <h1>Pointeurs : atelier visuel</h1>
      <p class="subtitle">40+ mini-slides, exemples, piÃ¨ges, dÃ©fis avec corrections</p>
    </div>

    <!-- Slide 2: Objectifs -->
    <div class="slide">
      <h2>Objectifs du module</h2>
      <ul>
        <li>RÃ©viser adresses, pointeurs, rÃ©fÃ©rences sans magie</li>
        <li>RepÃ©rer et Ã©viter les piÃ¨ges courants (dangling, off-by-one, fuite)</li>
        <li>Savoir choisir valeur / rÃ©fÃ©rence / pointeur</li>
        <li>Pratiquer avec des dÃ©fis courts + solutions</li>
        <li>Garder une fiche rÃ©flexe simple</li>
      </ul>
    </div>

    <!-- Slide 3: PrÃ©-requis -->
    <div class="slide">
      <h2>Ce que vous savez dÃ©jÃ </h2>
      <ul>
        <li>DÃ©clarer des variables (<code>int</code>, <code>double</code>, <code>std::string</code>)</li>
        <li>Ã‰crire des fonctions simples et utiliser des tableaux</li>
        <li>Utiliser <code>for</code>, <code>while</code> et des conditions</li>
      </ul>
      <div class="info-box">On reste Ã  ce niveau : pas de template avancÃ© ni de move.</div>
    </div>

    <!-- Slide 4: MÃ©taphore visuelle -->
    <div class="slide">
      <h2>BoÃ®te & Ã©tiquette</h2>
      <ul>
        <li>Variable = boÃ®te contenant une valeur</li>
        <li>Adresse = Ã©tiquette collÃ©e sur la boÃ®te</li>
        <li>Pointeur = papier avec lâ€™adresse notÃ©e dessus</li>
      </ul>
      <div class="info-box">Dessiner des boÃ®tes et des flÃ¨ches aide Ã©normÃ©ment.</div>
    </div>

    <!-- Slide 5: OÃ¹ vit la donnÃ©e ? -->
    <div class="slide">
      <h2>Pile vs tas (rapide)</h2>
      <ul>
        <li>Pile (stack) : variables locales, durÃ©e = fin du bloc</li>
        <li>Tas (heap) : via <code>new</code>/<code>delete</code>, durÃ©e = jusquâ€™Ã  libÃ©ration</li>
        <li>Adresse = lieu en mÃ©moire; le pointeur la mÃ©morise</li>
      </ul>
      <div class="code-example"><pre>// SchÃ©ma simplifiÃ© (bas = plus hautes adresses)
// PILE (automatique)
// | main x=10 | f() local | ...
// |-----------|-----------|
// TAS (new/delete)
// |  bloc A   |  bloc B   | ...
// +------------------------+
</pre></div>
      <div class="info-box">Pile : crÃ©Ã©/dÃ©truit automatiquement Ã  lâ€™entrÃ©e/sortie du bloc (rapide, pas de delete). Tas : crÃ©Ã© avec <code>new</code>/<code>new[]</code>, doit Ãªtre libÃ©rÃ© avec <code>delete</code>/<code>delete[]</code> (ou gÃ©rÃ© par <code>std::vector</code>/<code>std::unique_ptr</code>). Un pointeur note lâ€™adresse, pas la durÃ©e de vie.</div>
    </div>

    <!-- Slide 5b: Exemple pile -->
    <div class="slide">
      <h2>Exemple pile (auto)</h2>
      <div class="code-example"><pre>void f(){
  int local = 3;    // vit pendant f
  std::cout &lt;&lt; &amp;local; // adresse sur la pile
}                    // local dÃ©truit ici
int main(){
  f();              // la pile se nettoie seule
}</pre></div>
      <div class="code-example"><pre>// Stack frame de f
// | local=3 |   &lt;-- &amp;local
// (sortie) frame retirÃ©e : local n'existe plus
</pre></div>
      <div class="info-box">Aucune <code>delete</code>: la pile libÃ¨re tout Ã  la fin du bloc.</div>
    </div>

    <!-- Slide 5c: Exemple tas -->
    <div class="slide">
      <h2>Exemple tas (dyn)</h2>
      <div class="code-example"><pre>int main(){
  int* p = new int(42); // sur le tas
  std::cout &lt;&lt; *p &lt;&lt; " @" &lt;&lt; p;
  delete p;             // libÃ©ration manuelle
  p = nullptr;          // Ã©vite un pointeur sauvage
}</pre></div>
      <div class="code-example"><pre>// Pile (main)        Tas
// | p = 0x600... |   | [42] |
//       |------------^
// (delete) bloc tas libÃ©rÃ©, p remis Ã  nullptr
</pre></div>
      <div class="info-box">Le tas vit plus longtemps que le bloc, mais vous devez libÃ©rer. Alternative sÃ»re : <code>auto p = std::make_unique&lt;int&gt;(42);</code></div>
    </div>

    <!-- Slide 6: Lire une adresse -->
    <div class="slide">
      <h2>Obtenir lâ€™adresse</h2>
      <div class="code-example"><pre>#include &lt;iostream&gt;
int main(){
  int x = 12;
  std::cout &lt;&lt; "x vaut " &lt;&lt; x &lt;&lt; "\n";
  std::cout &lt;&lt; "adresse de x : " &lt;&lt; &amp;x &lt;&lt; "\n";
}</pre></div>
      <div class="info-box"><code>&amp;x</code> se lit Â« adresse de x Â».</div>
    </div>

    <!-- Slide 7: DÃ©clarer un pointeur -->
    <div class="slide">
      <h2>DÃ©claration</h2>
      <div class="code-example"><pre>int* p = nullptr; // p peut viser un int
double *q = nullptr; // style au choix
int a = 5;
p = &amp;a; // p Â« regarde Â» a</pre></div>
      <div class="info-box">Toujours initialiser (souvent Ã  <code>nullptr</code>).</div>
    </div>

    <!-- Slide 8: DÃ©rÃ©fÃ©rencer -->
    <div class="slide">
      <h2>AccÃ©der via *</h2>
      <div class="code-example"><pre>int a = 7;
int* p = &amp;a;
std::cout &lt;&lt; *p; // lit 7
*p = 9;           // modifie a
std::cout &lt;&lt; a;  // affiche 9</pre></div>
      <div class="info-box">DÃ©rÃ©fÃ©rencer = suivre la flÃ¨che du pointeur.</div>
    </div>

    <!-- Slide 9: Visuel de modification -->
    <div class="slide">
      <h2>Changer via pointeur</h2>
      <div class="code-example"><pre>void set_to_zero(int* p){
  if (p) *p = 0;
}
int main(){
  int score = 15;
  set_to_zero(&amp;score);
  // score est devenu 0
}</pre></div>
      <div class="info-box">Un pointeur permet de modifier la boÃ®te visÃ©e.</div>
    </div>

    <!-- Slide 10: nullptr -->
    <div class="slide">
      <h2>nullptr & pointeur sauvage</h2>
      <ul>
        <li><code>nullptr</code> = ne pointe vers rien â†’ doit Ãªtre testÃ©</li>
        <li>Pointeur sauvage = non initialisÃ© ou dÃ©jÃ  libÃ©rÃ©</li>
        <li>Ne jamais dÃ©rÃ©fÃ©rencer un pointeur non vÃ©rifiÃ©</li>
      </ul>
    </div>

    <!-- Slide 11: Non initialisÃ© = danger -->
    <div class="slide">
      <h2>Pointeur non initialisÃ©</h2>
      <div class="code-example"><pre>int* p;      // ?? valeur alÃ©atoire
// *p = 3;  // ğŸš« crash/UB possible
p = nullptr; // âœ… maintenant sÃ»r Ã  tester</pre></div>
      <div class="info-box">RÃ¨gle: initialiser tout de suite.</div>
    </div>

    <!-- Slide 12: Dangling (variable locale) -->
    <div class="slide">
      <h2>Dangling pointer</h2>
      <div class="code-example"><pre>int* bad(){
  int x = 5;
  return &amp;x; // ğŸš« x dÃ©truit aprÃ¨s la fonction
}</pre></div>
      <div class="code-example"><pre>// PILE pendant bad()
// | x=5 (adresse 0x7ff...) |
// (sortie de bad) le bloc est libÃ©rÃ©
// &amp;x pointe vers une zone morte â†’ imprÃ©visible
</pre></div>
      <div class="info-box">Ne jamais retourner lâ€™adresse dâ€™une variable locale; alternatives simples :
<br>- retourner la valeur : <code>int good(){ return 5; }</code>
<br>- ou allouer dans le tas (Ã  libÃ©rer ensuite) : <code>int* good(){ return new int(5); }</code></div>
    </div>

    <!-- Slide 13: Optionnel vs obligatoire -->
    <div class="slide">
      <h2>RÃ©fÃ©rence ou pointeur ?</h2>
      <div class="code-example"><pre>void force_present(int&amp; r){ r = 10; }      // doit exister
void peut_manquer(int* p){ if(p) *p = 10; } // peut Ãªtre nul</pre></div>
      <div class="info-box">Choix rapide :
<br>- RÃ©fÃ©rence (<code>&amp;</code>) si lâ€™argument est obligatoire (jamais nul)
<br>- Pointeur (<code>*</code>) si lâ€™argument peut manquer (<code>nullptr</code> acceptÃ©)
<br>- Const rÃ©f pour lire un gros objet sans copie : <code>void show(const Data&amp; d)</code>
<br>- Copie (<code>T</code>) si vous voulez une valeur indÃ©pendante</div>
    </div>

    <!-- Slide 14: RÃ©fÃ©rence rappel -->
    <div class="slide">
      <h2>RÃ©fÃ©rence (alias)</h2>
      <div class="code-example"><pre>int n = 4;
int&amp; ref = n; // ref et n = mÃªme boÃ®te
ref += 1;     // n vaut 5
// int&amp; r;   // ğŸš« doit Ãªtre initialisÃ©e
</pre></div>
      <div class="info-box">Une rÃ©fÃ©rence ne se Â« rebinde Â» pas.</div>
    </div>

    <!-- Slide 15: Tableau comparatif -->
    <div class="slide">
      <h2>Valeur / &amp; / *</h2>
      <ul>
        <li>Valeur: copie indÃ©pendante</li>
        <li>RÃ©f (<code>&amp;</code>): alias obligatoire, jamais nul</li>
        <li>Pointeur (<code>*</code>): peut Ãªtre nul, nÃ©cessite test</li>
      </ul>
    </div>

    <!-- Slide 16: Choisir rapidement -->
    <div class="slide">
      <h2>Raccourci de choix</h2>
      <ul>
        <li>Lecture sans copie dâ€™un gros objet : <code>const T&amp;</code></li>
        <li>Besoin de modifier et lâ€™objet existe : <code>T&amp;</code></li>
        <li>Peut Ãªtre absent : <code>T*</code> + test <code>if(p)</code></li>
        <li>Copie volontaire, vie propre : <code>T</code></li>
      </ul>
    </div>

    <!-- Slide 17: Swap -->
    <div class="slide">
      <h2>Exemple swap</h2>
      <div class="code-example"><pre>void swap_ref(int&amp; a, int&amp; b){ int t=a; a=b; b=t; }
void swap_ptr(int* a, int* b){
  if(!a || !b) return;
  int t=*a; *a=*b; *b=t;
}</pre></div>
      <div class="info-box">Version rÃ©fÃ©rence = plus simple si toujours prÃ©sents.</div>
    </div>

    <!-- Slide 18: ParamÃ¨tre Â« sortie Â» -->
    <div class="slide">
      <h2>Passer un rÃ©sultat</h2>
      <div class="code-example"><pre>bool diviser(double a, double b, double&amp; resultat){
  if (b==0) return false;
  resultat = a/b; return true;
}</pre></div>
      <div class="info-box">Sortie garantie â†’ rÃ©fÃ©rence.</div>
    </div>

    <!-- Slide 19: ParamÃ¨tre optionnel -->
    <div class="slide">
      <h2>Sortie optionnelle</h2>
      <div class="code-example"><pre>bool diviser_opt(double a, double b, double* out){
  if (!out || b==0) return false;
  *out = a/b; return true;
}</pre></div>
      <div class="info-box">Optionnel â†’ pointeur + test.</div>
    </div>

    <!-- Slide 20: Mini dÃ©fi -->
    <div class="slide">
      <h2>DÃ©fi : corrigez</h2>
      <div class="code-example"><pre>int* f(){
  int v = 3;
  return &amp;v; // corriger
}</pre></div>
      <div class="info-box">Indice: durÃ©e de vie de <code>v</code>.</div>
    </div>

    <!-- Slide 21: Tableaux et pointeurs -->
    <div class="slide">
      <h2>Tableau â‡’ pointeur</h2>
      <div class="code-example"><pre>int t[4] = {1,2,3,4};
int* p = t;     // = &amp;t[0]
std::cout &lt;&lt; p[2]; // 3</pre></div>
    </div>

    <!-- Slide 22: Deux notations -->
    <div class="slide">
      <h2>t[i] == *(t+i)</h2>
      <div class="code-example"><pre>int t[3]={10,20,30};
int* p = t;
int a = t[1];    // 20
int b = *(p+1);  // 20</pre></div>
      <div class="info-box">MÃªme accÃ¨s, choisissez la plus lisible.</div>
    </div>

    <!-- Slide 23: ArithmÃ©tique simple -->
    <div class="slide">
      <h2>Avancer le pointeur</h2>
      <div class="code-example"><pre>int t[5]={0,1,2,3,4};
int* p = t;
++p;       // pointe t[1]
p += 2;   // pointe t[3]
</pre></div>
      <div class="info-box">Ajouter 1 avance de <code>sizeof(int)</code> octets.</div>
    </div>

    <!-- Slide 23b: Visuel arithmÃ©tique -->
    <div class="slide">
      <h2>Visuel sur un tableau</h2>
      <div class="code-example"><pre>// t : [10][20][30][40]
//      ^t        ^t+2
int* p = t;    // pointe 10
p = p + 1;     // pointe 20
*(p+1);        // lit 30</pre></div>
      <div class="info-box">Index i â‡” <code>*(t+i)</code>. Un pas = un Ã©lÃ©ment, pas un octet.</div>
    </div>

    <!-- Slide 23c: Adresses observÃ©es -->
    <div class="slide">
      <h2>Adresses qui bougent</h2>
      <div class="code-example"><pre>int t[3]={5,6,7};
std::cout &lt;&lt; &amp;t[0] &lt;&lt; "\n";
std::cout &lt;&lt; &amp;t[1] &lt;&lt; "\n";
// souvent +4 octets sur int 32 bits</pre></div>
      <div class="info-box">Lâ€™arithmÃ©tique suit lâ€™espacement entre les Ã©lÃ©ments.</div>
    </div>

    <!-- Slide 23d: Off-by-one -->
    <div class="slide">
      <h2>Attention au +1</h2>
      <div class="code-example"><pre>int t[3]={1,2,3};
int* fin = t + 3; // juste aprÃ¨s
// t+4 // ğŸš« hors zone
for(int* p=t; p!=fin; ++p){
  std::cout &lt;&lt; *p;
}</pre></div>
      <div class="info-box">Dernier Ã©lÃ©ment: <code>t[2]</code>. <code>t+3</code> sert de marqueur, on ne le dÃ©rÃ©fÃ©rence pas.</div>
    </div>

    <!-- Slide 24: Limites -->
    <div class="slide">
      <h2>Rester dans le tableau</h2>
      <ul>
        <li>Zone valide: de <code>&amp;t[0]</code> inclus Ã  <code>&amp;t[n]</code> exclus</li>
        <li><code>t+n</code> (Â« one-past-end Â») sert de fin, on ne lit/Ã©crit pas dessus</li>
        <li>DÃ©passer <code>t[n-1]</code> = dÃ©bordement (comportement indÃ©fini)</li>
      </ul>
      <div class="code-example"><pre>// Tableau t[4] : index 0..3
// |0|1|2|3|fin|
//  ^t       ^t+4 (fin, ne pas lire)
int* fin = t + 4;
for(int* p=t; p!=fin; ++p) { /* ok */ }</pre></div>
      <div class="info-box">RÃ¨gle clÃ© : <code>p</code> reste dans <code>[t, t+n]</code>; seul <code>t+n</code> est autorisÃ© sans dÃ©rÃ©fÃ©rence.</div>
    </div>

    <!-- Slide 25: Parcours pointer -->
    <div class="slide">
      <h2>Parcours par pointeur</h2>
      <div class="code-example"><pre>void afficher(const int* debut, int n){
  const int* fin = debut + n;
  for(const int* p = debut; p != fin; ++p){
    std::cout &lt;&lt; *p &lt;&lt; ' ';
  }
}</pre></div>
    </div>

    <!-- Slide 26: Recherche -->
    <div class="slide">
      <h2>Renvoi dâ€™adresse trouvÃ©e</h2>
      <div class="code-example"><pre>int* find(int* t, int n, int cible){
  for(int i=0;i&lt;n;++i) if (t[i]==cible) return &amp;t[i];
  return nullptr;
}</pre></div>
      <div class="info-box">Renvoie <code>nullptr</code> si absent.</div>
    </div>

    <!-- Slide 27: Tableaux 2D -->
    <div class="slide">
      <h2>Tableaux 2D fixes</h2>
      <div class="code-example"><pre>void print2(const int m[][3], int rows){
  for(int i=0;i&lt;rows;++i){
    for(int j=0;j&lt;3;++j) std::cout &lt;&lt; m[i][j] &lt;&lt; ' ';
    std::cout &lt;&lt; "\n";
  }
}
int M[2][3]={{1,2,3},{4,5,6}};</pre></div>
      <div class="info-box">La 2áµ‰ dimension doit Ãªtre connue.</div>
    </div>

    <!-- Slide 27b: MÃ©moire en ligne -->
    <div class="slide">
      <h2>Comment câ€™est rangÃ©</h2>
      <div class="code-example"><pre>// int M[2][3] = { {1,2,3}, {4,5,6} };
// MÃ©moire contiguÃ« (row-major) :
// [1][2][3][4][5][6]
//  ^M[0][0] ...       ^M[1][2]
</pre></div>
      <div class="info-box">StockÃ© ligne par ligne. AprÃ¨s <code>M[0][2]</code> vient <code>M[1][0]</code>.</div>
    </div>

    <!-- Slide 27c: Pourquoi fixer la 2e dim -->
    <div class="slide">
      <h2>Pourquoi fixer la 2áµ‰ dimension ?</h2>
      <div class="code-example"><pre>const int COLS = 3;
void print2(const int m[][COLS], int rows);
// Le compilateur connaÃ®t COLS pour Â« sauter Â» la bonne longueur
// et atteindre m[i][j].</pre></div>
      <div class="info-box">Astuce: poser <code>COLS</code> en <code>const int</code> et lâ€™utiliser dans la signature.</div>
    </div>

    <!-- Slide 27d: Variante allocation dynamique -->
    <div class="slide">
      <h2>2D dynamique simple</h2>
      <div class="code-example"><pre>#include &lt;vector&gt;
std::vector&lt;std::vector&lt;int&gt;&gt; mat(2, std::vector&lt;int&gt;(3, 0));
mat[1][2] = 9; // pas besoin de delete</pre></div>
      <div class="info-box">Pour tailles variables, prÃ©fÃ©rer <code>std::vector&lt;std::vector&lt;T&gt;&gt;</code> (simple) ou un seul vector 1D avec index <code>i*cols + j</code>.</div>
    </div>

    <!-- Slide 28: C-string -->
    <div class="slide">
      <h2>ChaÃ®nes en C</h2>
      <div class="code-example"><pre>char s[] = "Salut"; // 6 cases avec '\0'
const char* p = s;
std::cout &lt;&lt; p; // affiche Salut</pre></div>
    </div>

    <!-- Slide 29: PiÃ¨ge C-string -->
    <div class="slide">
      <h2>Oubli du '\0'</h2>
      <div class="code-example"><pre>char s[5] = {'H','e','l','l','o'}; // ğŸš« pas de '\0'
std::cout &lt;&lt; s; // lit au-delÃ , rÃ©sultat imprÃ©visible</pre></div>
      <div class="info-box">Toujours prÃ©voir une case pour <code>'\\0'</code>.</div>
    </div>

    <!-- Slide 30: PrÃ©fÃ©rer std::string -->
    <div class="slide">
      <h2>std::string simplifie</h2>
      <div class="code-example"><pre>std::string nom = "Ada";
nom += " Lovelace";
// pas de gestion manuelle du '\0'</pre></div>
      <div class="info-box">Utiliser <code>char*</code> seulement si nÃ©cessaire.</div>
    </div>

    <!-- Slide 31: const et pointeur -->
    <div class="slide">
      <h2>4 combinaisons const</h2>
      <div class="code-example"><pre>const int* p;   // lit des int
int* const q = nullptr; // q fixe, vers int modifiable
const int* const r = nullptr; // cible et pointeur figÃ©s
int const * s; // identique Ã  const int*</pre></div>
      <div class="info-box">Le <code>const</code> touche ce qui est Ã  gauche de <code>*</code>.</div>
    </div>

    <!-- Slide 32: const & rÃ©fÃ©rences -->
    <div class="slide">
      <h2>RÃ©f et const</h2>
      <div class="code-example"><pre>void afficher(const std::string&amp; s){
  std::cout &lt;&lt; s;
}</pre></div>
      <div class="info-box">Ã‰vite copie, garantit aucune modification.</div>
    </div>

    <!-- Slide 33: Struct et pointeur -->
    <div class="slide">
      <h2>Pointeur sur struct</h2>
      <div class="code-example"><pre>struct Point { double x, y; };
Point p{1.0, 2.0};
Point* ptr = &amp;p;
ptr-&gt;x = 3.5; // modifie p.x
</pre></div>
    </div>

    <!-- Slide 34: new/delete (pÃ©dago) -->
    <div class="slide">
      <h2>new / delete (Ã  limiter)</h2>
      <div class="code-example"><pre>int* p = new int(5);
// ... usage
delete p; p = nullptr;</pre></div>
      <div class="info-box">Toujours un <code>delete</code> pour chaque <code>new</code>.</div>
    </div>

    <!-- Slide 35: Tableaux dynamiques -->
    <div class="slide">
      <h2>new[] / delete[]</h2>
      <div class="code-example"><pre>int* t = new int[3]{1,2,3};
// ...
delete[] t; t = nullptr;</pre></div>
      <div class="info-box">Ne jamais mÃ©langer <code>new</code> avec <code>delete[]</code>.</div>
    </div>

    <!-- Slide 36: Fuite et double delete -->
    <div class="slide">
      <h2>PiÃ¨ges de gestion</h2>
      <ul>
        <li>Fuite: oubli de <code>delete</code> â†’ mÃ©moire jamais rendue</li>
        <li>Double delete: libÃ©rer deux fois la mÃªme adresse â†’ crash</li>
        <li>MÃ©lange <code>new</code>/<code>free</code> ou <code>malloc</code>/<code>delete</code> : interdit</li>
      </ul>
      <div class="info-box">Antidotes : un seul propriÃ©taire clair (ou <code>std::unique_ptr</code>), remettre le pointeur Ã  <code>nullptr</code> aprÃ¨s <code>delete</code>, et ne jamais mÃ©langer les familles dâ€™allocation/libÃ©ration.</div>
    </div>

    <!-- Slide 36b: Exemple fuite -->
    <div class="slide">
      <h2>Exemple de fuite</h2>
      <div class="code-example"><pre>void f(){
  int* p = new int(5);
  // ... on oublie delete p;
} // fuite : jamais libÃ©rÃ©</pre></div>
      <div class="info-box">Solution : <code>delete p;</code> ou mieux, <code>auto p = std::make_unique&lt;int&gt;(5);</code> pour libÃ©ration auto.</div>
    </div>

    <!-- Slide 36c: Exemple double delete -->
    <div class="slide">
      <h2>Exemple double delete</h2>
      <div class="code-example"><pre>int* p = new int(7);
delete p;
// ...
delete p; // ğŸš« mÃªme adresse libÃ©rÃ©e deux fois
</pre></div>
      <div class="info-box">Remettre Ã  <code>nullptr</code> aprÃ¨s delete ou laisser un unique_ptr gÃ©rer : <code>auto p = std::make_unique&lt;int&gt;(7);</code></div>
    </div>

    <!-- Slide 37: Alternative simple -->
    <div class="slide">
      <h2>PrÃ©fÃ©rer std::vector</h2>
      <div class="code-example"><pre>#include &lt;vector&gt;
std::vector&lt;int&gt; v = {1,2,3};
v.push_back(4); // pas de delete</pre></div>
      <div class="info-box">Pas de pointeurs bruts â†’ moins de piÃ¨ges.</div>
    </div>

    <!-- Slide 38: Proprietaire unique -->
    <div class="slide">
      <h2>std::unique_ptr (simple)</h2>
      <div class="code-example"><pre>#include &lt;memory&gt;
auto p = std::make_unique&lt;int&gt;(42);
// dÃ©truit automatiquement en fin de scope</pre></div>
      <div class="info-box">Un seul propriÃ©taire â†’ pas de fuite, pas de double delete.</div>
    </div>

    <!-- Slide 39: Outils anti-piÃ¨ge -->
    <div class="slide">
      <h2>Tester et tracer</h2>
      <ul>
        <li><code>if(p)</code> avant dÃ©rÃ©fÃ©rence</li>
        <li><code>assert(p)</code> pour pointeur supposÃ© non nul</li>
        <li>Afficher adresses et valeurs pendant le debug</li>
      </ul>
    </div>

    <!-- Slide 40: Fiche rÃ©flexe -->
    <div class="slide">
      <h2>Check-list rapide</h2>
      <ul>
        <li>Initialiser Ã  <code>nullptr</code></li>
        <li>Tester avant <code>*p</code></li>
        <li>Qui libÃ¨re ? (un seul responsable)</li>
        <li>Rester dans les bornes des tableaux</li>
        <li>PrÃ©fÃ©rer <code>std::string</code>, <code>std::vector</code></li>
      </ul>
    </div>

    <!-- Slide 41: DÃ©fi 1 -->
    <div class="slide">
      <h2>DÃ©fi : somme par pointeurs</h2>
      <div class="code-example"><pre>int somme(const int* t, int n){
  // TODO: retourner la somme
}</pre></div>
      <div class="info-box">Indice: boucle <code>for</code> ou pointeur qui avance.</div>
    </div>

    <!-- Slide 42: Solution 1 -->
    <div class="slide">
      <h2>Solution somme</h2>
      <div class="code-example"><pre>int somme(const int* t, int n){
  int s = 0;
  const int* fin = t + n;
  for(const int* p = t; p != fin; ++p) s += *p;
  return s;
}</pre></div>
    </div>

    <!-- Slide 43: DÃ©fi 2 -->
    <div class="slide">
      <h2>DÃ©fi : sÃ©curiser</h2>
      <div class="code-example"><pre>void copie10(int* dest, const int* src){
  for(int i=0;i&lt;10;++i) dest[i] = src[i];
}</pre></div>
      <div class="info-box">Ajoutez des garde-fous (tests simples).</div>
    </div>

    <!-- Slide 44: Solution 2 -->
    <div class="slide">
      <h2>Solution sÃ©curisÃ©e</h2>
      <div class="code-example"><pre>bool copie10(int* dest, const int* src){
  if(!dest || !src) return false;
  for(int i=0;i&lt;10;++i) dest[i] = src[i];
  return true;
}</pre></div>
    </div>

    <!-- Controls -->
    <div class="controls">
      <button id="prevBtn" onclick="changeSlide(-1)">â† PrÃ©cÃ©dent</button>
      <span class="slide-number"><span id="currentSlide">1</span> / <span id="totalSlides">54</span></span>
      <button id="nextBtn" onclick="changeSlide(1)">Suivant â†’</button>
    </div>
  </div>

  <script src="assets/js/cpp_intro.js"></script>
</body>
</html>
