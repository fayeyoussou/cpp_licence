<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Atelier Pointeurs 2 ‚Äî Pi√®ges & pratique</title>
  <link rel="stylesheet" href="assets/css/cpp_intro.css">
  <meta name="description" content="Atelier pointeurs C/C++ : pieges courants, new/delete, debogage, exercices et corrections.">
</head>
<body>
  <div class="presentation-container">
    <a class="back-link" href="index.html">‚Üê Retour au menu</a>

    <!-- Slide 1 -->
    <div class="slide active title-slide">
      <h1>Pointeurs ‚Äî Atelier 2</h1>
      <p class="subtitle">Pi√®ges, gestion memoire, exercices</p>
    </div>

    <!-- Slide 2 -->
    <div class="slide">
      <h2>Objectifs</h2>
      <ul>
        <li>Identifier et corriger les pieges classiques</li>
        <li>new/delete : quoi faire, quoi eviter</li>
        <li>Bornes, +1, chaines C, 2D : erreurs typiques</li>
        <li>Habitudes de debug et check-list</li>
        <li>Exercices avec solutions</li>
      </ul>
    </div>

    <!-- Slide 3 -->
    <div class="slide">
      <h2>Reflexes de base</h2>
      <ul>
        <li>Initialiser a <code>nullptr</code></li>
        <li>Tester <code>if(p)</code> avant <code>*p</code></li>
        <li>Un seul responsable de la lib√©ration</li>
        <li>Rester dans les bornes des tableaux</li>
      </ul>
    </div>

    <!-- Slide 4 -->
    <div class="slide">
      <h2>Dangling pointer</h2>
      <div class="code-example"><pre>int* bad(){
  int x = 5;
  return &amp;x; // x detruit a la sortie
}</pre></div>
      <div class="code-example"><pre>// PILE pendant bad() : | x=5 |
// sortie : frame retiree, &amp;x pointe vers du mort</pre></div>
      <div class="info-box">Corriger : retourner la valeur, ou allouer sur le tas et lib√©rer ensuite.</div>
    </div>

    <!-- Slide 5 -->
    <div class="slide">
      <h2>Optionnel vs obligatoire</h2>
      <div class="code-example"><pre>void force_present(int&amp; r){ r = 10; }
void peut_manquer(int* p){ if(p) *p = 10; }</pre></div>
      <div class="info-box">Reference = jamais nulle; pointeur = peut etre <code>nullptr</code>, toujours tester.</div>
    </div>

    <!-- Slide 6 -->
    <div class="slide">
      <h2>Off-by-one</h2>
      <div class="code-example"><pre>int t[3]={1,2,3};
int* fin = t + 3; // one-past-end
for(int* p=t; p!=fin; ++p){ std::cout &lt;&lt; *p; }</pre></div>
      <div class="info-box">Ne jamais acceder a <code>t+3</code>, c‚Äôest juste un marqueur de fin.</div>
    </div>

    <!-- Slide 7 -->
    <div class="slide">
      <h2>Chaine C sans '\\0'</h2>
      <div class="code-example"><pre>char s[5] = {'H','e','l','l','o'}; // üö´ pas de '\\0'
std::cout &lt;&lt; s; // lit au-dela</pre></div>
      <div class="info-box">Toujours la case du <code>'\\0'</code> ou utiliser <code>std::string</code>.</div>
    </div>

    <!-- Slide 8 -->
    <div class="slide">
      <h2>new/delete (pedago)</h2>
      <div class="code-example"><pre>int* p = new int(5);
// ...
delete p; p=nullptr;</pre></div>
      <div class="info-box">A utiliser rarement; preferer <code>std::vector</code>/<code>std::unique_ptr</code>.</div>
    </div>

    <!-- Slide 9 -->
    <div class="slide">
      <h2>new[] / delete[]</h2>
      <div class="code-example"><pre>int* t = new int[3]{1,2,3};
// ...
delete[] t; t = nullptr;</pre></div>
      <div class="info-box">Ne jamais m√©langer <code>new</code> avec <code>delete[]</code>.</div>
    </div>

    <!-- Slide 10 -->
    <div class="slide">
      <h2>Pi√®ges de gestion</h2>
      <ul>
        <li>Fuite: oubli de <code>delete</code> ‚Üí memoire garde</li>
        <li>Double delete: meme adresse liberee deux fois</li>
      </ul>
      <div class="info-box">Antidotes : un seul proprietaire ou <code>std::unique_ptr</code>; remettre a <code>nullptr</code> apres <code>delete</code>.</div>
    </div>

    <!-- Slide 11 -->
    <div class="slide">
      <h2>Exemple de fuite</h2>
      <div class="code-example"><pre>void f(){
  int* p = new int(5);
  // ... on oublie delete p;
} // fuite</pre></div>
      <div class="info-box">Solution : <code>delete p;</code> ou <code>auto p = std::make_unique&lt;int&gt;(5);</code></div>
    </div>

    <!-- Slide 12 -->
    <div class="slide">
      <h2>Exemple double delete</h2>
      <div class="code-example"><pre>int* p = new int(7);
delete p;
// ...
delete p; // üö´ meme adresse</pre></div>
      <div class="info-box">Remettre a <code>nullptr</code> ou laisser <code>unique_ptr</code> gerer.</div>
    </div>

    <!-- Slide 13 -->
    <div class="slide">
      <h2>Tableau dynamique simple</h2>
      <div class="code-example"><pre>int* t = new int[5]{1,2,3,4,5};
for(int i=0; i&lt;5; ++i){
  std::cout &lt;&lt; t[i] &lt;&lt; " ";
}
delete[] t; t = nullptr;</pre></div>
      <div class="info-box">Toujours utiliser <code>delete[]</code> avec <code>new[]</code>.</div>
    </div>

    <!-- Slide 14 -->
    <div class="slide">
      <h2>Pr√©f√©rer std::vector</h2>
      <div class="code-example"><pre>#include &lt;vector&gt;
std::vector&lt;int&gt; v = {1,2,3};
v.push_back(4); // pas de delete</pre></div>
      <div class="info-box">Evite fuites et double delete.</div>
    </div>

    <!-- Slide 15 -->
    <div class="slide">
      <h2>std::unique_ptr (simple)</h2>
      <div class="code-example"><pre>#include &lt;memory&gt;
auto p = std::make_unique&lt;int&gt;(42);
// detruit automatiquement</pre></div>
      <div class="info-box">Un seul proprietaire ‚Üí moins de pieges.</div>
    </div>

    <!-- Slide 16 -->
    <div class="slide">
      <h2>Outils anti-piege</h2>
      <ul>
        <li><code>if(p)</code>, <code>assert(p)</code> pour preconditions</li>
        <li>Afficher adresse + valeur en debug</li>
      </ul>
    </div>

    <!-- Slide 17 -->
    <div class="slide">
      <h2>Fiche reflexe</h2>
      <ul>
        <li>Initialiser, tester</li>
        <li>Un seul delete, jamais double</li>
        <li>Pas de m√©lange <code>new</code>/<code>free</code></li>
        <li>Rester dans les bornes</li>
        <li>Pr√©ferer <code>std::vector</code>, <code>std::string</code>, <code>std::unique_ptr</code></li>
      </ul>
    </div>

    <!-- Slide 18 -->
    <div class="slide">
      <h2>D√©fi : somme</h2>
      <div class="code-example"><pre>int somme(const int* t, int n){
  // TODO: retourner la somme
}</pre></div>
    </div>

    <!-- Slide 19 -->
    <div class="slide">
      <h2>Solution somme</h2>
      <div class="code-example"><pre>int somme(const int* t, int n){
  int s = 0;
  const int* fin = t + n;
  for(const int* p = t; p != fin; ++p) s += *p;
  return s;
}</pre></div>
    </div>

    <!-- Slide 20 -->
    <div class="slide">
      <h2>D√©fi : copie securisee</h2>
      <div class="code-example"><pre>void copie10(int* dest, const int* src){
  for(int i=0;i&lt;10;++i) dest[i] = src[i];
}</pre></div>
      <div class="info-box">Ajouter des gardes simples.</div>
    </div>

    <!-- Slide 21 -->
    <div class="slide">
      <h2>Solution copie</h2>
      <div class="code-example"><pre>bool copie10(int* dest, const int* src){
  if(!dest || !src) return false;
  for(int i=0;i&lt;10;++i) dest[i] = src[i];
  return true;
}</pre></div>
    </div>

    <!-- Slide 22 -->
    <div class="slide">
      <h2>int* vs std::vector : allocation</h2>
      <div class="code-example"><pre>// Avec new[] : gestion manuelle
int* tab1 = new int[5];
for(int i=0; i&lt;5; ++i) tab1[i] = i;
// ... utilisation ...
delete[] tab1; // ‚ùå si oubli = fuite !
tab1 = nullptr;

// Avec vector : automatique
#include &lt;vector&gt;
std::vector&lt;int&gt; tab2(5); // init √† 0
for(int i=0; i&lt;5; ++i) tab2[i] = i;
// ... utilisation ...
// ‚úÖ destruction automatique !</pre></div>
      <div class="info-box">vector g√®re la m√©moire automatiquement, pas de delete n√©cessaire.</div>
    </div>

    <!-- Slide 23 -->
    <div class="slide">
      <h2>int* vs std::vector : redimensionnement</h2>
      <div class="code-example"><pre>// Avec new[] : impossible de redimensionner
int* tab1 = new int[5];
// Pour agrandir : recr√©er tout !
int* temp = new int[10];
for(int i=0; i&lt;5; ++i) temp[i] = tab1[i];
delete[] tab1;
tab1 = temp; // compliqu√© et risqu√©

// Avec vector : facile et s√ªr
std::vector&lt;int&gt; tab2 = {1,2,3,4,5};
tab2.push_back(6); // ‚úÖ ajouter un √©l√©ment
tab2.resize(10);   // ‚úÖ redimensionner
// taille connue : tab2.size()</pre></div>
      <div class="info-box">vector g√®re automatiquement la capacit√© et la taille.</div>
    </div>

    <!-- Slide 24 -->
    <div class="slide">
      <h2>new int vs std::unique_ptr</h2>
      <div class="code-example"><pre>// Avec new : risque de fuite
int* p1 = new int(42);
// ... si exception ici ...
delete p1; // ‚ùå jamais execut√© !

// Avec unique_ptr : s√ªr
#include &lt;memory&gt;
auto p2 = std::make_unique&lt;int&gt;(42);
// ... m√™me si exception ...
// ‚úÖ destruction automatique !

// Acc√®s identique
*p1 = 100;  // d√©r√©f√©rencement
*p2 = 100;  // pareil !</pre></div>
      <div class="info-box">unique_ptr lib√®re automatiquement, m√™me en cas d'exception.</div>
    </div>

    <!-- Slide 25 -->
    <div class="slide">
      <h2>Comparaison tableaux dynamiques</h2>
      <div class="code-example"><pre>// new[] : manuel, dangereux
int* t1 = new int[5]{1,2,3,4,5};
int taille1 = 5; // √† suivre manuellement !
// t1[10] = 0; // ‚ùå crash, pas de v√©rification
delete[] t1;

// vector : s√ªr, flexible
std::vector&lt;int&gt; t2 = {1,2,3,4,5};
int taille2 = t2.size(); // ‚úÖ connu automatiquement
// t2.at(10) = 0; // ‚úÖ exception si hors bornes
t2.push_back(6); // ‚úÖ agrandi si besoin
// destruction auto</pre></div>
      <div class="info-box">vector connait sa taille et peut v√©rifier les acc√®s avec <code>.at()</code>.</div>
    </div>

    <!-- Slide 26 -->
    <div class="slide">
      <h2>Exemple complet : pourquoi std::vector</h2>
      <div class="code-example"><pre>#include &lt;iostream&gt;
#include &lt;vector&gt;
using namespace std;

int main(){
  vector&lt;int&gt; nombres; // vide au depart

  // Ajouter des elements facilement
  for(int i=0; i&lt;10; ++i){
    nombres.push_back(i * i); // 0,1,4,9,16...
  }

  // Connaitre la taille
  cout &lt;&lt; "Taille : " &lt;&lt; nombres.size() &lt;&lt; endl;

  // Parcourir
  for(int val : nombres){
    cout &lt;&lt; val &lt;&lt; " ";
  }

  // Pas de delete, pas de fuite !
  return 0;
}</pre></div>
    </div>

    <!-- Slide 27 -->
    <div class="slide">
      <h2>Tableau comparatif</h2>
      <table style="width:100%; border-collapse:collapse; margin:20px 0;">
        <tr style="background:#2d2d2d;">
          <th style="border:1px solid #555; padding:10px;">Crit√®re</th>
          <th style="border:1px solid #555; padding:10px;">new/delete</th>
          <th style="border:1px solid #555; padding:10px;">vector/unique_ptr</th>
        </tr>
        <tr>
          <td style="border:1px solid #555; padding:10px;">Gestion m√©moire</td>
          <td style="border:1px solid #555; padding:10px;">‚ùå Manuelle</td>
          <td style="border:1px solid #555; padding:10px;">‚úÖ Automatique</td>
        </tr>
        <tr>
          <td style="border:1px solid #555; padding:10px;">Risque de fuite</td>
          <td style="border:1px solid #555; padding:10px;">‚ùå √âlev√©</td>
          <td style="border:1px solid #555; padding:10px;">‚úÖ Nul</td>
        </tr>
        <tr>
          <td style="border:1px solid #555; padding:10px;">Taille connue</td>
          <td style="border:1px solid #555; padding:10px;">‚ùå √Ä suivre</td>
          <td style="border:1px solid #555; padding:10px;">‚úÖ .size()</td>
        </tr>
        <tr>
          <td style="border:1px solid #555; padding:10px;">Redimensionner</td>
          <td style="border:1px solid #555; padding:10px;">‚ùå Complexe</td>
          <td style="border:1px solid #555; padding:10px;">‚úÖ push_back()</td>
        </tr>
        <tr>
          <td style="border:1px solid #555; padding:10px;">S√©curit√©</td>
          <td style="border:1px solid #555; padding:10px;">‚ùå Aucune</td>
          <td style="border:1px solid #555; padding:10px;">‚úÖ .at() v√©rifie</td>
        </tr>
      </table>
      <div class="info-box">Pr√©f√©rer vector et unique_ptr sauf contrainte sp√©cifique.</div>
    </div>

    <div class="controls">
      <button id="prevBtn" onclick="changeSlide(-1)">‚Üê Pr√©c√©dent</button>
      <span class="slide-number"><span id="currentSlide">1</span> / <span id="totalSlides">27</span></span>
      <button id="nextBtn" onclick="changeSlide(1)">Suivant ‚Üí</button>
    </div>
  </div>

  <script src="assets/js/cpp_intro.js"></script>
</body>
</html>
