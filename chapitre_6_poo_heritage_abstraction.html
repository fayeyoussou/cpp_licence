<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chapitre 6 — POO : Héritage & Abstraction</title>
    <link rel="stylesheet" href="assets/css/cpp_intro.css">
    <meta name="description" content="POO L2 : héritage simple/multiple, override/final, accès, ordre de construction, classes abstraites et interfaces. Prépare le polymorphisme du chapitre suivant." />
</head>
<body>
    <div class="presentation-container">
        <a class="back-link" href="index.html">← Retour au menu</a>

        <div class="slide active title-slide">
            <h1>Chapitre 6 — Héritage &amp; Abstraction</h1>
            <p class="subtitle">Construire des familles de classes cohérentes</p>
        </div>

        <div class="slide">
            <h2>Objectifs</h2>
            <ul>
                <li>Quand utiliser l'héritage pour modéliser un « est-un »</li>
                <li>Comprendre l'accès en héritage (public/protected/private)</li>
                <li>Sécuriser les redéfinitions avec <code>override</code>/<code>final</code></li>
                <li>Gérer l'ordre constructeurs/destructeurs avec héritage</li>
                <li>Découvrir classes abstraites et interfaces</li>
            </ul>
        </div>

        <div class="slide">
            <h2>Rappel des 4 piliers</h2>
            <ul>
                <li>Encapsulation : état protégé (chap. 5)</li>
                <li>Héritage : réutiliser/étendre une base commune</li>
                <li>Polymorphisme : un appel, plusieurs implémentations (chap. 7)</li>
                <li>Abstraction : interface minimale, détails cachés</li>
            </ul>
        </div>

        <div class="slide">
            <h2>Pourquoi l'héritage ?</h2>
            <ul>
                <li>Éviter la duplication de code commun</li>
                <li>Exprimer un lien « est-un » évident (Chat est un Animal)</li>
                <li>Partager une interface commune pour des usages polymorphes</li>
                <li>Si le lien n'est pas clair → préférer composition</li>
            </ul>
        </div>

        <div class="slide">
            <h2>Est-un vs A-un</h2>
            <ul>
                <li><strong>Est-un</strong> (inheritance) : le type dérivé respecte l'interface base</li>
                <li><strong>A-un</strong> (composition) : l'objet contient un autre objet</li>
                <li>Ex : Voiture est-un Véhicule ; Voiture a-un Moteur</li>
                <li>Utiliser l'héritage seulement si chaque dérivé peut être utilisé comme la base</li>
            </ul>
        </div>

        <div class="slide">
            <h2>Base et dérivée (simple)</h2>
            <div class="code-example"><pre>class Animal {
public:
    void manger() {}
    void parler() const { std::cout << \"...\"; }
};

class Chien : public Animal {
public:
    void parler() const { std::cout << \"woof\"; }
};

Chien c;
c.manger();   // hérité
c.parler();   // version dérivée
</pre></div>
            <ul>
                <li><code>public</code> : l'interface de la base reste publique</li>
                <li>La dérivée peut ajouter ou spécialiser des comportements</li>
            </ul>
        </div>

        <div class="slide">
            <h2>Accès en héritage</h2>
            <ul>
                <li>Héritage <strong>public</strong> : public→public, protected→protected</li>
                <li>Héritage <strong>protected</strong> : public→protected pour les dérivés</li>
                <li>Héritage <strong>private</strong> : public/protected→private (non visible de l'extérieur)</li>
                <li>Choisir <code>public</code> pour un vrai « est-un »</li>
            </ul>
        </div>

        <div class="slide">
            <h2>Encapsulation &amp; héritage</h2>
            <ul>
                <li>La base protège ses invariants : surface minimale d'API publique</li>
                <li><code>protected</code> expose aux dérivés ce qui est nécessaire, rien de plus</li>
                <li>Ne pas rendre <code>private</code> public dans un dérivé si l'invariant de la base en dépend</li>
                <li>Documenter ce que la dérivée peut ou ne peut pas modifier</li>
            </ul>
        </div>

        <div class="slide">
            <h2>public / protected / private</h2>
            <ul>
                <li><code>public</code> : visible partout</li>
                <li><code>protected</code> : visible dans la classe et ses dérivées</li>
                <li><code>private</code> : visible uniquement dans la classe</li>
                <li>Par défaut dans <code>class</code> : <code>private</code></li>
            </ul>
        </div>

        <div class="slide">
            <h2><code>protected</code> en pratique</h2>
            <div class="code-example"><pre>class Figure {
protected:
    double surface_ = 0;
};

class Disque : public Figure {
public:
    Disque(double r) { surface_ = 3.14 * r * r; }
    double aire() const { return surface_; }
};
</pre></div>
            <p><code>protected</code> partage avec les dérivés sans exposer au reste du code.</p>
        </div>

        <div class="slide">
            <h2>Héritage privé (adapter)</h2>
            <div class="code-example"><pre>class PileBase {
public:
    void push(int v) { data_.push_back(v); }
    void pop() { data_.pop_back(); }
protected:
    std::vector<int> data_;
};

class PileBornée : private PileBase {
public:
    void push(int v) {
        if (data_.size() >= 10) throw std::logic_error(\"plein\");
        PileBase::push(v);
    }
    using PileBase::pop; // on expose seulement ce qui est voulu
};
</pre></div>
        </div>

        <div class="slide">
            <h2>Réexposer une méthode</h2>
            <div class="code-example"><pre>class Base {
public:
    void reset();
protected:
    void log();
};

class Derivee : public Base {
public:
    using Base::log; // rend log() public ici
};
</pre></div>
            <p><code>using</code> permet de choisir ce qui remonte dans l'interface publique.</p>
        </div>

        <div class="slide">
            <h2>Override vs masquage</h2>
            <div class="code-example"><pre>class Forme {
public:
    virtual void afficher() const;
};

class Cercle : public Forme {
public:
    void afficher() const override; // override = sécurité
};

class Triangle : public Forme {
public:
    void afficher(int precision) const; // masque afficher() de base
};
</pre></div>
            <ul>
                <li><code>override</code> : impose même signature</li>
                <li>Signature différente → masquage (la version base est cachée)</li>
            </ul>
        </div>

        <div class="slide">
            <h2>Erreurs fréquentes (override)</h2>
            <ul>
                <li>Changer le type de retour ou les const → pas un override</li>
                <li>Oublier <code>override</code> : le compilateur ne peut pas vous aider</li>
                <li>Oublier <code>virtual</code> dans la base : la dérivée masque au lieu de redéfinir</li>
            </ul>
        </div>

        <div class="slide">
            <h2><code>final</code> sur méthodes/classes</h2>
            <div class="code-example"><pre>class Base {
public:
    virtual void f() const;
    virtual void g() const final; // interdit une redéfinition
};

class Scellee final : public Base {
public:
    void f() const override;
};
</pre></div>
            <p><code>final</code> verrouille une méthode ou une classe dérivable.</p>
        </div>

        <div class="slide">
            <h2>Destructeur virtuel ?</h2>
            <ul>
                <li>Si la classe est destinée à être dérivée et utilisée via un pointeur/référence base → destructeur <code>virtual</code></li>
                <li>Sinon, destructeur non virtuel suffit</li>
            </ul>
            <div class="code-example"><pre>class Forme {
public:
    virtual ~Forme() = default;
};</pre></div>
        </div>

        <div class="slide">
            <h2>Constructeurs &amp; destruction</h2>
            <ul>
                <li>Construction : base d'abord, puis dérivé</li>
                <li>Destruction : dérivé d'abord, puis base</li>
                <li>Appeler le constructeur base en liste d'init du dérivé</li>
            </ul>
            <div class="code-example"><pre>class Vehicule {
public:
    Vehicule(int id) : id_(id) { std::cout << \"Vehicule\\n\"; }
    ~Vehicule() { std::cout << \"~Vehicule\\n\"; }
protected:
    int id_;
};

class Voiture : public Vehicule {
public:
    Voiture(int id, int portes) : Vehicule(id), portes_(portes) { std::cout << \"Voiture\\n\"; }
    ~Voiture() { std::cout << \"~Voiture\\n\"; }
private:
    int portes_;
};</pre></div>
        </div>

        <div class="slide">
            <h2>Ordre d'initialisation</h2>
            <ul>
                <li>Attributs initialisés dans l'ordre de déclaration (pas de la liste)</li>
                <li>Base avant dérivé</li>
                <li>Const et références doivent être initialisés dans la liste</li>
            </ul>
        </div>

        <div class="slide">
            <h2>Listes d'initialisation</h2>
            <div class="code-example"><pre>class Fenetre {
public:
    Fenetre(int w, int h) : largeur_(w), hauteur_(h) {}
private:
    int largeur_;
    int hauteur_;
};

class FenetreTitre : public Fenetre {
public:
    FenetreTitre(int w, int h, std::string titre)
        : Fenetre(w, h), titre_(std::move(titre)) {}
private:
    std::string titre_;
};</pre></div>
        </div>

        <div class="slide">
            <h2>Hériter des constructeurs</h2>
            <div class="code-example"><pre>class Base {
public:
    Base(int x, std::string nom);
};

class Derivee : public Base {
public:
    using Base::Base; // réutilise les constructeurs de Base
    Derivee() : Base(0, \"defaut\") {} // on peut en ajouter
};</pre></div>
            <ul>
                <li>Évite de recopier les signatures</li>
                <li>Ajoutez vos validations spécifiques si besoin</li>
            </ul>
        </div>

        <div class="slide">
            <h2>Appeler la version de base</h2>
            <div class="code-example"><pre>class Animal {
public:
    virtual void parler() const { std::cout << \"...\"; }
};

class Chien : public Animal {
public:
    void parler() const override {
        Animal::parler(); // optionnel : comportement commun
        std::cout << \"woof\";
    }
};</pre></div>
        </div>

        <div class="slide">
            <h2>Héritage multiple (aperçu)</h2>
            <ul>
                <li>Plusieurs bases : <code>class X : public A, public B</code></li>
                <li>Gérer les conflits de noms (<code>A::</code>, <code>B::</code>)</li>
                <li>Utiliser avec mesure</li>
            </ul>
        </div>

        <div class="slide">
            <h2>Diamant &amp; héritage virtuel</h2>
            <div class="code-example"><pre>class Appareil { };
class Camera : public virtual Appareil { };
class Telephone : public virtual Appareil { };
class Smartphone : public Camera, public Telephone { };
</pre></div>
            <p>L'héritage virtuel partage l'unique sous-objet <code>Appareil</code> pour éviter les duplications.</p>
        </div>

        <div class="slide">
            <h2>Classes abstraites</h2>
            <ul>
                <li>Au moins une méthode virtuelle pure (<code>= 0</code>)</li>
                <li>Non instanciables directement</li>
                <li>Définissent un contrat minimal</li>
            </ul>
            <div class="code-example"><pre>class Strategie {
public:
    virtual ~Strategie() = default;
    virtual double appliquer(double valeur) const = 0; // pure
};</pre></div>
        </div>

        <div class="slide">
            <h2>Interfaces pures</h2>
            <ul>
                <li>Pas de données membres</li>
                <li>Uniquement des méthodes virtuelles pures</li>
                <li>Permet de découpler l'appelant des implémentations</li>
            </ul>
            <div class="code-example"><pre>class Imprimable {
public:
    virtual ~Imprimable() = default;
    virtual void imprimer(std::ostream&) const = 0;
};</pre></div>
        </div>

        <div class="slide">
            <h2>Implémentation partielle</h2>
            <div class="code-example"><pre>class Forme {
public:
    virtual ~Forme() = default;
    virtual double aire() const = 0;
    void afficher() const { std::cout << aire(); } // implémentation commune
};</pre></div>
            <p>Une classe abstraite peut fournir du code commun et laisser des parties en <code>=0</code>.</p>
        </div>

        <div class="slide">
            <h2>Préparer le polymorphisme (chap. 7)</h2>
            <ul>
                <li>Interface commune dans la base</li>
                <li>Destructeur virtuel</li>
                <li>Méthodes marquées <code>virtual</code> + <code>override</code> dans les dérivés</li>
            </ul>
        </div>

        <div class="slide">
            <h2>Bonnes pratiques</h2>
            <ul>
                <li>Préférer composition si le lien « est-un » n'est pas clair</li>
                <li>Limiter la profondeur des hiérarchies</li>
                <li>Surface publique minimale dans la base</li>
                <li>Documenter responsabilités et invariants de la base</li>
            </ul>
        </div>

        <div class="slide">
            <h2>Checklist avant de dériver</h2>
            <ul>
                <li>Le dérivé respecte-t-il vraiment l'interface de la base ?</li>
                <li>Le destructeur de la base doit-il être <code>virtual</code> ?</li>
                <li>Quelles méthodes doivent être <code>override</code> ?</li>
                <li>Héritage public est-il justifié ? Sinon, composition.</li>
            </ul>
        </div>

        <div class="slide">
            <h2>Exemple complet mini</h2>
            <div class="code-example"><pre>class Vehicule {
public:
    virtual ~Vehicule() = default;
    virtual void afficher() const = 0;
};

class Velo : public Vehicule {
public:
    void afficher() const override { std::cout << \"Velo\"; }
};

class Voiture : public Vehicule {
public:
    void afficher() const override { std::cout << \"Voiture\"; }
};
</pre></div>
        </div>

        <div class="slide">
            <h2>Travail à réaliser</h2>
            <ul>
                <li>Créer <code>Vehicule</code> (base) puis <code>Voiture</code> et <code>Velo</code></li>
                <li>Ajouter une méthode virtuelle <code>afficher()</code> redéfinie dans chaque dérivé</li>
                <li>Tester l'ordre de construction/destruction (logs)</li>
                <li>Écrire une interface <code>Reparable</code> et l'implémenter dans vos dérivés</li>
            </ul>
        </div>

        <div class="controls">
            <button id="prevBtn" onclick="changeSlide(-1)">← Précédent</button>
            <span class="slide-number"><span id="currentSlide">1</span> / <span id="totalSlides">31</span></span>
            <button id="nextBtn" onclick="changeSlide(1)">Suivant →</button>
        </div>
    </div>

    <script src="assets/js/cpp_intro.js"></script>
</body>
</html>
